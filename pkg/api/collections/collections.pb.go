// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: collections/collections.proto

package collections

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// 排序方向
type Order_Direction int32

const (
	// 升序
	Order_ASCENDING Order_Direction = 0
	// 降序
	Order_DESCENDING Order_Direction = 1
)

var Order_Direction_name = map[int32]string{
	0: "ASCENDING",
	1: "DESCENDING",
}

var Order_Direction_value = map[string]int32{
	"ASCENDING":  0,
	"DESCENDING": 1,
}

func (x Order_Direction) String() string {
	return proto.EnumName(Order_Direction_name, int32(x))
}

func (Order_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{1, 0}
}

// 复合过滤器操作符
type CompositeFilter_Operator int32

const (
	// 结果要求满足每个过滤器
	CompositeFilter_AND CompositeFilter_Operator = 0
	// 结果要求满足任一过滤器
	CompositeFilter_OR CompositeFilter_Operator = 1
)

var CompositeFilter_Operator_name = map[int32]string{
	0: "AND",
	1: "OR",
}

var CompositeFilter_Operator_value = map[string]int32{
	"AND": 0,
	"OR":  1,
}

func (x CompositeFilter_Operator) String() string {
	return proto.EnumName(CompositeFilter_Operator_name, int32(x))
}

func (CompositeFilter_Operator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{3, 0}
}

// 属性过滤器操作符
type PropertyFilter_Operator int32

const (
	// 等于
	PropertyFilter_EQUAL PropertyFilter_Operator = 0
	// 小于
	PropertyFilter_LESS_THAN PropertyFilter_Operator = 1
	// 小于或等于
	PropertyFilter_LESS_THAN_OR_EQUAL PropertyFilter_Operator = 2
	// 大于
	PropertyFilter_GREATER_THAN PropertyFilter_Operator = 3
	// 大于或等于
	PropertyFilter_GREATER_THAN_OR_EQUAL PropertyFilter_Operator = 4
	// 字符串包含
	PropertyFilter_LIKE PropertyFilter_Operator = 5
	// 不等于
	PropertyFilter_NOT_EQUAL PropertyFilter_Operator = 6
	// 数组包含，属性域必须是数组
	PropertyFilter_ARRAY_CONTAINS PropertyFilter_Operator = 7
	// 在数组中，要求值是非空数组
	PropertyFilter_IN PropertyFilter_Operator = 8
)

var PropertyFilter_Operator_name = map[int32]string{
	0: "EQUAL",
	1: "LESS_THAN",
	2: "LESS_THAN_OR_EQUAL",
	3: "GREATER_THAN",
	4: "GREATER_THAN_OR_EQUAL",
	5: "LIKE",
	6: "NOT_EQUAL",
	7: "ARRAY_CONTAINS",
	8: "IN",
}

var PropertyFilter_Operator_value = map[string]int32{
	"EQUAL":                 0,
	"LESS_THAN":             1,
	"LESS_THAN_OR_EQUAL":    2,
	"GREATER_THAN":          3,
	"GREATER_THAN_OR_EQUAL": 4,
	"LIKE":                  5,
	"NOT_EQUAL":             6,
	"ARRAY_CONTAINS":        7,
	"IN":                    8,
}

func (x PropertyFilter_Operator) String() string {
	return proto.EnumName(PropertyFilter_Operator_name, int32(x))
}

func (PropertyFilter_Operator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{4, 0}
}

// 关于类型表达式属性的引用
type PropertyReference struct {
	// 属性名字
	// 如果名字中包含"."，需要将其解释为路径
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropertyReference) Reset()         { *m = PropertyReference{} }
func (m *PropertyReference) String() string { return proto.CompactTextString(m) }
func (*PropertyReference) ProtoMessage()    {}
func (*PropertyReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{0}
}
func (m *PropertyReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyReference.Merge(m, src)
}
func (m *PropertyReference) XXX_Size() int {
	return m.Size()
}
func (m *PropertyReference) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyReference.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyReference proto.InternalMessageInfo

func (m *PropertyReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// 特定属性的排序(order)
type Order struct {
	// 排序属性
	Property *PropertyReference `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	// 排序方向. 默认升序 `ASCENDING`.
	Direction            Order_Direction `protobuf:"varint,2,opt,name=direction,proto3,enum=api.collections.Order_Direction" json:"direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{1}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetProperty() *PropertyReference {
	if m != nil {
		return m.Property
	}
	return nil
}

func (m *Order) GetDirection() Order_Direction {
	if m != nil {
		return m.Direction
	}
	return Order_ASCENDING
}

// 包含任何类型的过滤器(filter)
type Filter struct {
	// 过滤器类型.
	//
	// Types that are valid to be assigned to FilterType:
	//	*Filter_CompositeFilter
	//	*Filter_PropertyFilter
	FilterType           isFilter_FilterType `protobuf_oneof:"filter_type"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{2}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

type isFilter_FilterType interface {
	isFilter_FilterType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Filter_CompositeFilter struct {
	CompositeFilter *CompositeFilter `protobuf:"bytes,1,opt,name=compositeFilter,proto3,oneof" json:"compositeFilter,omitempty"`
}
type Filter_PropertyFilter struct {
	PropertyFilter *PropertyFilter `protobuf:"bytes,2,opt,name=propertyFilter,proto3,oneof" json:"propertyFilter,omitempty"`
}

func (*Filter_CompositeFilter) isFilter_FilterType() {}
func (*Filter_PropertyFilter) isFilter_FilterType()  {}

func (m *Filter) GetFilterType() isFilter_FilterType {
	if m != nil {
		return m.FilterType
	}
	return nil
}

func (m *Filter) GetCompositeFilter() *CompositeFilter {
	if x, ok := m.GetFilterType().(*Filter_CompositeFilter); ok {
		return x.CompositeFilter
	}
	return nil
}

func (m *Filter) GetPropertyFilter() *PropertyFilter {
	if x, ok := m.GetFilterType().(*Filter_PropertyFilter); ok {
		return x.PropertyFilter
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Filter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Filter_CompositeFilter)(nil),
		(*Filter_PropertyFilter)(nil),
	}
}

// 复合过滤器(CompositeFilter)，根据操作符合并多个其他过滤器
type CompositeFilter struct {
	// 组合多个过滤器的操作符
	Op CompositeFilter_Operator `protobuf:"varint,1,opt,name=op,proto3,enum=api.collections.CompositeFilter_Operator" json:"op,omitempty"`
	// 组合的过滤器列表
	// 必需包含至少一个过滤器
	Filters              []*Filter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CompositeFilter) Reset()         { *m = CompositeFilter{} }
func (m *CompositeFilter) String() string { return proto.CompactTextString(m) }
func (*CompositeFilter) ProtoMessage()    {}
func (*CompositeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{3}
}
func (m *CompositeFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompositeFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompositeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeFilter.Merge(m, src)
}
func (m *CompositeFilter) XXX_Size() int {
	return m.Size()
}
func (m *CompositeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeFilter proto.InternalMessageInfo

func (m *CompositeFilter) GetOp() CompositeFilter_Operator {
	if m != nil {
		return m.Op
	}
	return CompositeFilter_AND
}

func (m *CompositeFilter) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// 属性过滤器(PropertyFilter)，在特定属性上的过滤器
type PropertyFilter struct {
	// 过滤的属性
	Property *PropertyReference `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	// 过滤的操作符
	Op PropertyFilter_Operator `protobuf:"varint,2,opt,name=op,proto3,enum=api.collections.PropertyFilter_Operator" json:"op,omitempty"`
	// 和属性比较的值(value)
	Value                *Value   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropertyFilter) Reset()         { *m = PropertyFilter{} }
func (m *PropertyFilter) String() string { return proto.CompactTextString(m) }
func (*PropertyFilter) ProtoMessage()    {}
func (*PropertyFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{4}
}
func (m *PropertyFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyFilter.Merge(m, src)
}
func (m *PropertyFilter) XXX_Size() int {
	return m.Size()
}
func (m *PropertyFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyFilter proto.InternalMessageInfo

func (m *PropertyFilter) GetProperty() *PropertyReference {
	if m != nil {
		return m.Property
	}
	return nil
}

func (m *PropertyFilter) GetOp() PropertyFilter_Operator {
	if m != nil {
		return m.Op
	}
	return PropertyFilter_EQUAL
}

func (m *PropertyFilter) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// 分页
type Page struct {
	// 页数
	PageIndex int32 `protobuf:"varint,1,opt,name=pageIndex,proto3" json:"pageIndex,omitempty"`
	// 分页大小
	PageSize             int32    `protobuf:"varint,2,opt,name=pageSize,proto3" json:"pageSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Page) Reset()         { *m = Page{} }
func (m *Page) String() string { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()    {}
func (*Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{5}
}
func (m *Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Page.Merge(m, src)
}
func (m *Page) XXX_Size() int {
	return m.Size()
}
func (m *Page) XXX_DiscardUnknown() {
	xxx_messageInfo_Page.DiscardUnknown(m)
}

var xxx_messageInfo_Page proto.InternalMessageInfo

func (m *Page) GetPageIndex() int32 {
	if m != nil {
		return m.PageIndex
	}
	return 0
}

func (m *Page) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// 一个能够包含所以所有的值类型的消息(message)
type Value struct {
	// 必须有一种值
	//
	// Types that are valid to be assigned to ValueType:
	//	*Value_BooleanValue
	//	*Value_IntegerValue
	//	*Value_DoubleValue
	//	*Value_StringValue
	//	*Value_BytesValue
	//	*Value_ArrayValue
	ValueType            isValue_ValueType `protobuf_oneof:"value_type"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{6}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_ValueType interface {
	isValue_ValueType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_BooleanValue struct {
	BooleanValue bool `protobuf:"varint,1,opt,name=booleanValue,proto3,oneof" json:"booleanValue,omitempty"`
}
type Value_IntegerValue struct {
	IntegerValue int64 `protobuf:"varint,2,opt,name=integerValue,proto3,oneof" json:"integerValue,omitempty"`
}
type Value_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,3,opt,name=doubleValue,proto3,oneof" json:"doubleValue,omitempty"`
}
type Value_StringValue struct {
	StringValue string `protobuf:"bytes,17,opt,name=stringValue,proto3,oneof" json:"stringValue,omitempty"`
}
type Value_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,18,opt,name=bytesValue,proto3,oneof" json:"bytesValue,omitempty"`
}
type Value_ArrayValue struct {
	ArrayValue *ArrayValue `protobuf:"bytes,9,opt,name=arrayValue,proto3,oneof" json:"arrayValue,omitempty"`
}

func (*Value_BooleanValue) isValue_ValueType() {}
func (*Value_IntegerValue) isValue_ValueType() {}
func (*Value_DoubleValue) isValue_ValueType()  {}
func (*Value_StringValue) isValue_ValueType()  {}
func (*Value_BytesValue) isValue_ValueType()   {}
func (*Value_ArrayValue) isValue_ValueType()   {}

func (m *Value) GetValueType() isValue_ValueType {
	if m != nil {
		return m.ValueType
	}
	return nil
}

func (m *Value) GetBooleanValue() bool {
	if x, ok := m.GetValueType().(*Value_BooleanValue); ok {
		return x.BooleanValue
	}
	return false
}

func (m *Value) GetIntegerValue() int64 {
	if x, ok := m.GetValueType().(*Value_IntegerValue); ok {
		return x.IntegerValue
	}
	return 0
}

func (m *Value) GetDoubleValue() float64 {
	if x, ok := m.GetValueType().(*Value_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *Value) GetStringValue() string {
	if x, ok := m.GetValueType().(*Value_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Value) GetBytesValue() []byte {
	if x, ok := m.GetValueType().(*Value_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

func (m *Value) GetArrayValue() *ArrayValue {
	if x, ok := m.GetValueType().(*Value_ArrayValue); ok {
		return x.ArrayValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_BooleanValue)(nil),
		(*Value_IntegerValue)(nil),
		(*Value_DoubleValue)(nil),
		(*Value_StringValue)(nil),
		(*Value_BytesValue)(nil),
		(*Value_ArrayValue)(nil),
	}
}

// 数组
type ArrayValue struct {
	// 数组中的值
	Values               []*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArrayValue) Reset()         { *m = ArrayValue{} }
func (m *ArrayValue) String() string { return proto.CompactTextString(m) }
func (*ArrayValue) ProtoMessage()    {}
func (*ArrayValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d526b8054cdfd87, []int{7}
}
func (m *ArrayValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArrayValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArrayValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArrayValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArrayValue.Merge(m, src)
}
func (m *ArrayValue) XXX_Size() int {
	return m.Size()
}
func (m *ArrayValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ArrayValue.DiscardUnknown(m)
}

var xxx_messageInfo_ArrayValue proto.InternalMessageInfo

func (m *ArrayValue) GetValues() []*Value {
	if m != nil {
		return m.Values
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.collections.Order_Direction", Order_Direction_name, Order_Direction_value)
	golang_proto.RegisterEnum("api.collections.Order_Direction", Order_Direction_name, Order_Direction_value)
	proto.RegisterEnum("api.collections.CompositeFilter_Operator", CompositeFilter_Operator_name, CompositeFilter_Operator_value)
	golang_proto.RegisterEnum("api.collections.CompositeFilter_Operator", CompositeFilter_Operator_name, CompositeFilter_Operator_value)
	proto.RegisterEnum("api.collections.PropertyFilter_Operator", PropertyFilter_Operator_name, PropertyFilter_Operator_value)
	golang_proto.RegisterEnum("api.collections.PropertyFilter_Operator", PropertyFilter_Operator_name, PropertyFilter_Operator_value)
	proto.RegisterType((*PropertyReference)(nil), "api.collections.PropertyReference")
	golang_proto.RegisterType((*PropertyReference)(nil), "api.collections.PropertyReference")
	proto.RegisterType((*Order)(nil), "api.collections.Order")
	golang_proto.RegisterType((*Order)(nil), "api.collections.Order")
	proto.RegisterType((*Filter)(nil), "api.collections.Filter")
	golang_proto.RegisterType((*Filter)(nil), "api.collections.Filter")
	proto.RegisterType((*CompositeFilter)(nil), "api.collections.CompositeFilter")
	golang_proto.RegisterType((*CompositeFilter)(nil), "api.collections.CompositeFilter")
	proto.RegisterType((*PropertyFilter)(nil), "api.collections.PropertyFilter")
	golang_proto.RegisterType((*PropertyFilter)(nil), "api.collections.PropertyFilter")
	proto.RegisterType((*Page)(nil), "api.collections.Page")
	golang_proto.RegisterType((*Page)(nil), "api.collections.Page")
	proto.RegisterType((*Value)(nil), "api.collections.Value")
	golang_proto.RegisterType((*Value)(nil), "api.collections.Value")
	proto.RegisterType((*ArrayValue)(nil), "api.collections.ArrayValue")
	golang_proto.RegisterType((*ArrayValue)(nil), "api.collections.ArrayValue")
}

func init() { proto.RegisterFile("collections/collections.proto", fileDescriptor_6d526b8054cdfd87) }
func init() {
	golang_proto.RegisterFile("collections/collections.proto", fileDescriptor_6d526b8054cdfd87)
}

var fileDescriptor_6d526b8054cdfd87 = []byte{
	// 706 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xdd, 0x6e, 0x12, 0x4d,
	0x1c, 0xc6, 0x99, 0xe5, 0xa3, 0xf0, 0x87, 0xd2, 0xed, 0xe4, 0x7d, 0xfb, 0xf2, 0xb6, 0x8a, 0x64,
	0x63, 0x22, 0x1a, 0xb3, 0x28, 0x9e, 0x68, 0xa2, 0x8d, 0x4b, 0xc1, 0x42, 0x24, 0x4b, 0x1d, 0xb0,
	0x89, 0x9e, 0x90, 0x65, 0x99, 0xae, 0x9b, 0x6e, 0x77, 0xd6, 0x65, 0x6b, 0xc4, 0x4b, 0xf0, 0x1a,
	0x8c, 0xd7, 0x60, 0xe2, 0x0d, 0x78, 0xe8, 0xa1, 0xa7, 0x9e, 0x99, 0x7a, 0x23, 0x66, 0x67, 0x60,
	0x59, 0x20, 0x4d, 0x0f, 0x3c, 0x9b, 0x79, 0xe6, 0xf7, 0x3c, 0x33, 0xff, 0xf9, 0x82, 0xeb, 0x26,
	0x73, 0x1c, 0x6a, 0x06, 0x36, 0x73, 0x27, 0xb5, 0x58, 0x5b, 0xf5, 0x7c, 0x16, 0x30, 0xbc, 0x65,
	0x78, 0xb6, 0x1a, 0x93, 0x77, 0xff, 0xb1, 0x98, 0xc5, 0xf8, 0x58, 0x2d, 0x6c, 0x09, 0x4c, 0xb9,
	0x05, 0xdb, 0x47, 0x3e, 0xf3, 0xa8, 0x1f, 0x4c, 0x09, 0x3d, 0xa1, 0x3e, 0x75, 0x4d, 0x8a, 0x31,
	0xa4, 0x5c, 0xe3, 0x8c, 0x96, 0xa4, 0x0a, 0xaa, 0xe6, 0x08, 0x6f, 0x2b, 0x5f, 0x11, 0xa4, 0x7b,
	0xfe, 0x98, 0xfa, 0x78, 0x1f, 0xb2, 0xde, 0xcc, 0x52, 0x42, 0x15, 0x54, 0xcd, 0xd7, 0x15, 0x75,
	0x65, 0x32, 0x75, 0x2d, 0x93, 0x44, 0x1e, 0xbc, 0x0f, 0xb9, 0xb1, 0xed, 0x0b, 0x92, 0x4f, 0x51,
	0xac, 0x57, 0xd6, 0x02, 0xf8, 0x54, 0x6a, 0x73, 0xce, 0x91, 0x85, 0x45, 0xb9, 0x03, 0xb9, 0x48,
	0xc7, 0x9b, 0x90, 0xd3, 0xfa, 0x07, 0x2d, 0xbd, 0xd9, 0xd1, 0x0f, 0xe5, 0x04, 0x2e, 0x02, 0x34,
	0x5b, 0x51, 0x1f, 0x29, 0x5f, 0x10, 0x64, 0x9e, 0xd9, 0x4e, 0x40, 0x7d, 0xdc, 0x85, 0x2d, 0x93,
	0x9d, 0x79, 0x6c, 0x62, 0x07, 0x54, 0x48, 0xb3, 0xd5, 0xaf, 0x4f, 0x7e, 0xb0, 0xcc, 0xb5, 0x13,
	0x64, 0xd5, 0x8a, 0x3b, 0x50, 0x9c, 0x17, 0x34, 0x0b, 0x93, 0x78, 0xd8, 0x8d, 0x4b, 0xb7, 0x22,
	0xca, 0x5a, 0x31, 0x36, 0x36, 0x21, 0x7f, 0xc2, 0x5b, 0xc3, 0x60, 0xea, 0x51, 0xe5, 0x13, 0x82,
	0xad, 0x95, 0x05, 0xe0, 0x47, 0x20, 0x31, 0x8f, 0x2f, 0xb7, 0x58, 0xbf, 0x7d, 0xd5, 0x72, 0xd5,
	0x9e, 0x47, 0x7d, 0x23, 0x60, 0x3e, 0x91, 0x98, 0x87, 0xef, 0xc3, 0x86, 0x48, 0x9f, 0x94, 0xa4,
	0x4a, 0xb2, 0x9a, 0xaf, 0xff, 0xb7, 0xe6, 0x17, 0x36, 0x32, 0xe7, 0x94, 0x3d, 0xc8, 0xce, 0x23,
	0xf0, 0x06, 0x24, 0x35, 0xbd, 0x29, 0x27, 0x70, 0x06, 0xa4, 0x1e, 0x91, 0x91, 0xf2, 0x53, 0x82,
	0xe2, 0x72, 0x49, 0x7f, 0x7d, 0x21, 0x1e, 0xf2, 0xea, 0xc4, 0x4d, 0xa8, 0x5e, 0xb1, 0x7f, 0xcb,
	0xc5, 0xdd, 0x85, 0xf4, 0x3b, 0xc3, 0x39, 0xa7, 0xa5, 0x24, 0x9f, 0x76, 0x67, 0xcd, 0x7c, 0x1c,
	0x8e, 0x12, 0x01, 0x29, 0x9f, 0x51, 0xac, 0xb0, 0x1c, 0xa4, 0x5b, 0x2f, 0x5e, 0x6a, 0x5d, 0x39,
	0x11, 0xde, 0xa1, 0x6e, 0xab, 0xdf, 0x1f, 0x0e, 0xda, 0x9a, 0x2e, 0x23, 0xbc, 0x03, 0x38, 0xea,
	0x0e, 0x7b, 0x64, 0x28, 0x30, 0x09, 0xcb, 0x50, 0x38, 0x24, 0x2d, 0x6d, 0xd0, 0x22, 0x82, 0x4c,
	0xe2, 0xff, 0xe1, 0xdf, 0xb8, 0xb2, 0x80, 0x53, 0x38, 0x0b, 0xa9, 0x6e, 0xe7, 0x79, 0x4b, 0x4e,
	0x87, 0xe9, 0x7a, 0x6f, 0x30, 0x1b, 0xc8, 0x60, 0x0c, 0x45, 0x8d, 0x10, 0xed, 0xd5, 0xf0, 0xa0,
	0xa7, 0x0f, 0xb4, 0x8e, 0xde, 0x97, 0x37, 0xc2, 0xbd, 0xed, 0xe8, 0x72, 0x56, 0x79, 0x0a, 0xa9,
	0x23, 0xc3, 0xa2, 0xf8, 0x1a, 0xe4, 0x3c, 0xc3, 0xa2, 0x1d, 0x77, 0x4c, 0xdf, 0xf3, 0x1d, 0x4d,
	0x93, 0x85, 0x80, 0x77, 0x21, 0x1b, 0x76, 0xfa, 0xf6, 0x07, 0xf1, 0x42, 0xd3, 0x24, 0xea, 0x2b,
	0x1f, 0x25, 0x48, 0xf3, 0x9a, 0xf1, 0x4d, 0x28, 0x8c, 0x18, 0x73, 0xa8, 0xe1, 0xf2, 0x3e, 0x8f,
	0xc9, 0xb6, 0x13, 0x64, 0x49, 0x0d, 0x29, 0xdb, 0x0d, 0xa8, 0x45, 0x7d, 0x41, 0x85, 0x79, 0xc9,
	0x90, 0x8a, 0xab, 0x58, 0x81, 0xfc, 0x98, 0x9d, 0x8f, 0x1c, 0x7a, 0x1c, 0x6d, 0x36, 0x6a, 0x27,
	0x48, 0x5c, 0x0c, 0x99, 0x49, 0xe0, 0xdb, 0xae, 0x25, 0x98, 0xed, 0xf0, 0xeb, 0x08, 0x99, 0x98,
	0x88, 0x2b, 0x00, 0xa3, 0x69, 0x40, 0x27, 0x02, 0xc1, 0x15, 0x54, 0x2d, 0xb4, 0x13, 0x24, 0xa6,
	0xe1, 0x27, 0x00, 0x86, 0xef, 0x1b, 0x53, 0x41, 0xe4, 0xf8, 0xa9, 0xee, 0xad, 0x9d, 0xaa, 0x16,
	0x21, 0xa1, 0x7d, 0x61, 0x68, 0x14, 0x00, 0xf8, 0x51, 0x8b, 0x97, 0xf4, 0x18, 0x60, 0x41, 0x62,
	0x15, 0x32, 0x7c, 0x6c, 0x52, 0x42, 0xfc, 0x1d, 0x5c, 0x76, 0x59, 0x66, 0x54, 0xa3, 0xf1, 0xfd,
	0xa2, 0x8c, 0x7e, 0x5c, 0x94, 0xd1, 0xaf, 0x8b, 0x32, 0xfa, 0xf6, 0xbb, 0x8c, 0x5e, 0xdf, 0x7b,
	0x6b, 0x1b, 0xae, 0x63, 0x07, 0xd4, 0x7c, 0xa3, 0x9a, 0xec, 0xac, 0x66, 0x3a, 0xec, 0x7c, 0x5c,
	0x1b, 0x19, 0xe6, 0x29, 0x75, 0xc7, 0x35, 0xef, 0xd4, 0xaa, 0x19, 0x9e, 0x1d, 0xff, 0x8a, 0x47,
	0x19, 0xfe, 0xc9, 0x3e, 0xf8, 0x13, 0x00, 0x00, 0xff, 0xff, 0x3e, 0xd1, 0xdb, 0x76, 0xac, 0x05,
	0x00, 0x00,
}

func (m *PropertyReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Direction != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if m.Property != nil {
		{
			size, err := m.Property.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FilterType != nil {
		{
			size := m.FilterType.Size()
			i -= size
			if _, err := m.FilterType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_CompositeFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_CompositeFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeFilter != nil {
		{
			size, err := m.CompositeFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Filter_PropertyFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_PropertyFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PropertyFilter != nil {
		{
			size, err := m.PropertyFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CompositeFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Op != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropertyFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Op != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if m.Property != nil {
		{
			size, err := m.Property.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PageSize != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if m.PageIndex != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PageIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ValueType != nil {
		{
			size := m.ValueType.Size()
			i -= size
			if _, err := m.ValueType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_BooleanValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BooleanValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BooleanValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Value_IntegerValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_IntegerValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCollections(dAtA, i, uint64(m.IntegerValue))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Value_DoubleValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DoubleValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleValue))))
	i--
	dAtA[i] = 0x19
	return len(dAtA) - i, nil
}
func (m *Value_ArrayValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ArrayValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ArrayValue != nil {
		{
			size, err := m.ArrayValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Value_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintCollections(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *Value_BytesValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BytesValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesValue != nil {
		i -= len(m.BytesValue)
		copy(dAtA[i:], m.BytesValue)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.BytesValue)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ArrayValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArrayValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArrayValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PropertyReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Property != nil {
		l = m.Property.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovCollections(uint64(m.Direction))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FilterType != nil {
		n += m.FilterType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filter_CompositeFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeFilter != nil {
		l = m.CompositeFilter.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *Filter_PropertyFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PropertyFilter != nil {
		l = m.PropertyFilter.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *CompositeFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovCollections(uint64(m.Op))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertyFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Property != nil {
		l = m.Property.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovCollections(uint64(m.Op))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageIndex != 0 {
		n += 1 + sovCollections(uint64(m.PageIndex))
	}
	if m.PageSize != 0 {
		n += 1 + sovCollections(uint64(m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValueType != nil {
		n += m.ValueType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Value_BooleanValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_IntegerValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCollections(uint64(m.IntegerValue))
	return n
}
func (m *Value_DoubleValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_ArrayValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArrayValue != nil {
		l = m.ArrayValue.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *Value_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 2 + l + sovCollections(uint64(l))
	return n
}
func (m *Value_BytesValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 2 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *ArrayValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PropertyReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Property == nil {
				m.Property = &PropertyReference{}
			}
			if err := m.Property.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Order_Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompositeFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterType = &Filter_CompositeFilter{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropertyFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PropertyFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FilterType = &Filter_PropertyFilter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= CompositeFilter_Operator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Property == nil {
				m.Property = &PropertyReference{}
			}
			if err := m.Property.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= PropertyFilter_Operator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageIndex", wireType)
			}
			m.PageIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BooleanValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ValueType = &Value_BooleanValue{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValueType = &Value_IntegerValue{v}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ValueType = &Value_DoubleValue{float64(math.Float64frombits(v))}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ArrayValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ValueType = &Value_ArrayValue{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueType = &Value_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.ValueType = &Value_BytesValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArrayValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArrayValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArrayValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Value{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
